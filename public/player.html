<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta content="width=device-width, initial-scale=1.0" name="viewport" />
    <title>ODS Player</title>
    <link href="https://fonts.googleapis.com" rel="preconnect" />
    <link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect" />
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@700&display=swap"
        rel="stylesheet" />
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:wght,FILL@100..700,0..1&display=swap"
        rel="stylesheet" />
    <script src="https://cdn.socket.io/4.6.0/socket.io.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html,
        body {
            background: #000 !important;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            font-family: 'Inter', -apple-system, sans-serif;
        }

        body {
            opacity: 0;
            transition: opacity 0.4s ease;
        }

        body.ready {
            opacity: 1;
        }

        /* ─── Content Display ─── */
        .player-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
        }

        .slide {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            transition: opacity 1s ease-in-out;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .slide.active {
            opacity: 1;
            z-index: 2;
        }

        .slide.outgoing {
            opacity: 0;
            z-index: 1;
        }

        .slide img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            background: #000;
        }

        .slide video {
            width: 100%;
            height: 100%;
            object-fit: contain;
            background: #000;
        }

        /* ─── Waiting for Content State ─── */
        .waiting-state {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: url('/resources/designs/ODS_Background.png') center/cover no-repeat;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        .waiting-state.hidden {
            display: none;
        }

        .waiting-card {
            background: rgba(255, 255, 255, 0.08) !important;
            backdrop-filter: blur(40px) !important;
            -webkit-backdrop-filter: blur(40px) !important;
            border: 1px solid rgba(255, 255, 255, 0.15) !important;
            border-radius: 24px !important;
            padding: 60px 48px !important;
            text-align: center;
            max-width: 520px;
            width: 90%;
        }

        .waiting-icon {
            font-size: 64px;
            color: rgba(255, 255, 255, 0.4);
            margin-bottom: 24px;
        }

        .waiting-title {
            font-size: 24px;
            font-weight: 700;
            color: #fff;
            margin-bottom: 8px;
            letter-spacing: -0.01em;
        }

        .waiting-subtitle {
            font-size: 15px;
            font-weight: 400;
            color: rgba(255, 255, 255, 0.5);
            line-height: 1.5;
            margin-bottom: 32px;
        }

        .waiting-pulse {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            padding: 10px 20px;
            border-radius: 100px;
            background: rgba(59, 130, 246, 0.12);
            border: 1px solid rgba(59, 130, 246, 0.2);
        }

        .waiting-pulse .dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #3b82f6;
            animation: pulse-dot 2s ease-in-out infinite;
        }

        .waiting-pulse span {
            font-size: 13px;
            font-weight: 500;
            color: rgba(59, 130, 246, 0.8);
            letter-spacing: 0.02em;
        }

        @keyframes pulse-dot {

            0%,
            100% {
                opacity: 0.3;
                transform: scale(0.8);
            }

            50% {
                opacity: 1;
                transform: scale(1.2);
            }
        }

        /* ─── Status Pill (bottom-right, minimal) ─── */
        .status-pill {
            position: fixed;
            bottom: 16px;
            right: 16px;
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 14px;
            border-radius: 100px;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            z-index: 100;
            opacity: 0.6;
            transition: opacity 0.3s ease;
        }

        .status-pill:hover {
            opacity: 1;
        }

        .status-pill .dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #10b981;
        }

        .status-pill .dot.offline {
            background: #ef4444;
        }

        .status-pill .dot.syncing {
            background: #f59e0b;
            animation: pulse-dot 1.5s ease-in-out infinite;
        }

        .status-pill .label {
            font-size: 11px;
            font-weight: 500;
            color: rgba(255, 255, 255, 0.6);
            font-family: 'JetBrains Mono', monospace;
        }

        /* ─── Progress Bar (thin, top edge) ─── */
        .slide-progress {
            position: fixed;
            top: 0;
            left: 0;
            height: 3px;
            background: rgba(59, 130, 246, 0.7);
            z-index: 50;
            transition: width linear;
            border-radius: 0 2px 2px 0;
        }

        /* ─── Keyboard lockdown ─── */
        body.locked * {
            user-select: none !important;
        }
    </style>
</head>

<body>
    <!-- Content Canvas -->
    <div class="player-canvas" id="playerCanvas"></div>

    <!-- Waiting for Content -->
    <div class="waiting-state" id="waitingState">
        <div class="waiting-card">
            <div class="waiting-icon">
                <span class="material-symbols-outlined" style="font-size: 64px;">tv_signin</span>
            </div>
            <div class="waiting-title">Paired & Ready</div>
            <div class="waiting-subtitle">
                This display is paired with ODS Cloud.<br>
                Assign a playlist from the dashboard to begin.
            </div>
            <div class="waiting-pulse">
                <div class="dot"></div>
                <span>Awaiting content</span>
            </div>
        </div>
    </div>

    <!-- Slide Progress Bar -->
    <div class="slide-progress" id="slideProgress"></div>

    <!-- Status Pill -->
    <div class="status-pill" id="statusPill">
        <div class="dot" id="statusDot"></div>
        <div class="label" id="statusLabel">connecting</div>
    </div>

    <script>
        // ========================================
        // ODS PLAYER — Content Renderer
        // ========================================
        const API_URL = 'https://api.ods-cloud.com';
        const CONFIG_POLL_INTERVAL = 30 * 1000;     // Check for config changes every 30s
        const HEARTBEAT_INTERVAL = 60 * 1000;       // Heartbeat every 60s
        const RECONNECT_DELAY = 5000;

        let playerId = localStorage.getItem('ods_player_id');
        let deviceUuid = localStorage.getItem('ods_device_uuid');
        let cpuSerial = localStorage.getItem('ods_cpu_serial');
        let socket = null;
        let currentConfig = null;
        let currentConfigHash = null;
        let slideTimer = null;
        let progressTimer = null;
        let currentSlideIndex = 0;
        let assets = [];

        // ─── Status Updates ───
        function setStatus(state, label) {
            const dot = document.getElementById('statusDot');
            const lbl = document.getElementById('statusLabel');
            dot.className = 'dot' + (state === 'offline' ? ' offline' : state === 'syncing' ? ' syncing' : '');
            lbl.textContent = label || state;
        }

        // ─── Redirect if not paired ───
        if (!playerId && !deviceUuid) {
            window.location.href = '/player_link.html';
        }

        // ─── WebSocket Connection ───
        function connectWebSocket() {
            socket = io(API_URL, {
                transports: ['websocket', 'polling'],
                reconnection: true,
                reconnectionDelay: RECONNECT_DELAY,
                reconnectionAttempts: Infinity
            });

            socket.on('connect', () => {
                console.log('[WS] Connected');
                setStatus('online', 'connected');

                // Register this player
                socket.emit('register', {
                    cpu_serial: cpuSerial,
                    name: localStorage.getItem('ods_device_name') || 'ODS Player',
                    device_uuid: deviceUuid
                });
            });

            socket.on('registered', (player) => {
                console.log('[WS] Registered:', player.id);
                if (!playerId) {
                    playerId = player.id;
                    localStorage.setItem('ods_player_id', playerId);
                }
            });

            // Real-time playlist deployment
            socket.on('deploy_playlist', async (data) => {
                console.log('[WS] Playlist deployed:', data);
                setStatus('syncing', 'syncing');
                await fetchConfig();
            });

            // Pairing success — reload config
            socket.on('pairing:success', async (data) => {
                if (data.device_uuid === deviceUuid) {
                    console.log('[WS] Pairing confirmed');
                    await fetchConfig();
                }
            });

            socket.on('disconnect', () => {
                console.log('[WS] Disconnected');
                setStatus('offline', 'offline');
            });

            socket.on('connect_error', (err) => {
                console.error('[WS] Connection error:', err.message);
                setStatus('offline', 'reconnecting');
            });
        }

        // ─── Heartbeat ───
        setInterval(() => {
            if (socket?.connected) {
                socket.emit('heartbeat', { player_id: playerId });
            }
        }, HEARTBEAT_INTERVAL);

        // ─── Config Fetch ───
        async function fetchConfig() {
            try {
                if (!deviceUuid) return;

                // First: lightweight hash check
                if (currentConfigHash) {
                    try {
                        const hashResp = await fetch(`${API_URL}/api/device/config/hash/${deviceUuid}`);
                        if (hashResp.ok) {
                            const hashData = await hashResp.json();
                            if (hashData.config_hash === currentConfigHash) {
                                console.log('[Config] No changes');
                                return; // Config unchanged
                            }
                        }
                    } catch (e) {
                        console.warn('[Config] Hash check failed, fetching full config');
                    }
                }

                // Full config fetch
                const resp = await fetch(`${API_URL}/api/device/config/${deviceUuid}`);
                if (!resp.ok) {
                    if (resp.status === 403) {
                        console.log('[Config] Device not paired yet');
                        showWaiting();
                        return;
                    }
                    console.error('[Config] Fetch failed:', resp.status);
                    return;
                }

                const config = await resp.json();
                currentConfig = config;
                currentConfigHash = config.config_hash;

                // Store player_id from config for WebSocket
                if (config.player_id && !playerId) {
                    playerId = config.player_id;
                    localStorage.setItem('ods_player_id', playerId);
                }

                console.log('[Config] Loaded:', {
                    playlist: config.playlist?.name,
                    assets: config.playlist?.assets?.length || 0
                });

                if (config.playlist && config.playlist.assets?.length > 0) {
                    await loadPlaylist(config.playlist);
                } else {
                    showWaiting();
                }

                setStatus('online', 'connected');

                // Report sync status
                if (socket?.connected) {
                    socket.emit('sync_status', {
                        status: 'synced',
                        config_hash: currentConfigHash,
                        downloaded: config.playlist?.assets?.length || 0
                    });
                }

            } catch (error) {
                console.error('[Config] Error:', error);
                setStatus('offline', 'error');
            }
        }

        // ─── Playlist Rendering ───
        function showWaiting() {
            document.getElementById('waitingState').classList.remove('hidden');
            document.getElementById('playerCanvas').innerHTML = '';
            document.getElementById('slideProgress').style.width = '0';
            clearTimeout(slideTimer);
            clearInterval(progressTimer);
            assets = [];
            currentSlideIndex = 0;
        }

        async function loadPlaylist(playlist) {
            // Hide waiting state
            document.getElementById('waitingState').classList.add('hidden');

            assets = playlist.assets.sort((a, b) => a.order - b.order);
            currentSlideIndex = 0;

            if (assets.length === 0) {
                showWaiting();
                return;
            }

            // Pre-create slide elements
            const canvas = document.getElementById('playerCanvas');
            canvas.innerHTML = '';

            assets.forEach((asset, i) => {
                const slide = document.createElement('div');
                slide.className = 'slide' + (i === 0 ? ' active' : '');
                slide.id = `slide-${i}`;

                if (asset.type === 'video') {
                    const video = document.createElement('video');
                    video.src = `${API_URL}${asset.url}`;
                    video.autoplay = (i === 0);
                    video.muted = true;
                    video.loop = false;
                    video.playsInline = true;
                    video.preload = 'auto';
                    video.addEventListener('ended', () => nextSlide());
                    video.addEventListener('error', (e) => {
                        console.error(`[Video] Error loading asset ${asset.id}:`, e);
                        nextSlide();
                    });
                    slide.appendChild(video);
                } else {
                    // Image (default)
                    const img = document.createElement('img');
                    img.src = `${API_URL}${asset.url}`;
                    img.alt = asset.filename || '';
                    img.loading = (i < 2) ? 'eager' : 'lazy';
                    img.addEventListener('error', (e) => {
                        console.error(`[Image] Error loading asset ${asset.id}:`, e);
                    });
                    slide.appendChild(img);
                }

                canvas.appendChild(slide);
            });

            // Start slideshow
            startSlideTimer();
        }

        function startSlideTimer() {
            clearTimeout(slideTimer);
            clearInterval(progressTimer);

            const asset = assets[currentSlideIndex];
            if (!asset) return;

            const slide = document.getElementById(`slide-${currentSlideIndex}`);
            const video = slide?.querySelector('video');

            // For videos, let the 'ended' event handle transition
            if (asset.type === 'video' && video) {
                video.currentTime = 0;
                video.play().catch(e => console.warn('[Video] Autoplay blocked:', e));
                // Progress bar for video
                const updateVideoProgress = () => {
                    if (video.duration) {
                        const pct = (video.currentTime / video.duration) * 100;
                        document.getElementById('slideProgress').style.width = `${pct}%`;
                    }
                    if (!video.ended) requestAnimationFrame(updateVideoProgress);
                };
                requestAnimationFrame(updateVideoProgress);
                return;
            }

            // For images, use duration timer
            const duration = (asset.duration || 10) * 1000;
            const progressBar = document.getElementById('slideProgress');
            progressBar.style.transition = 'none';
            progressBar.style.width = '0%';

            // Trigger reflow then animate
            requestAnimationFrame(() => {
                progressBar.style.transition = `width ${duration}ms linear`;
                progressBar.style.width = '100%';
            });

            slideTimer = setTimeout(() => nextSlide(), duration);
        }

        function nextSlide() {
            const prevIndex = currentSlideIndex;
            currentSlideIndex = (currentSlideIndex + 1) % assets.length;

            // Pause previous video
            const prevSlide = document.getElementById(`slide-${prevIndex}`);
            const prevVideo = prevSlide?.querySelector('video');
            if (prevVideo) prevVideo.pause();

            // Transition
            prevSlide?.classList.remove('active');
            prevSlide?.classList.add('outgoing');

            const nextSlideEl = document.getElementById(`slide-${currentSlideIndex}`);
            nextSlideEl?.classList.add('active');

            // Clean outgoing after transition
            setTimeout(() => {
                prevSlide?.classList.remove('outgoing');
            }, 1200);

            startSlideTimer();
        }

        // ─── Config Polling ───
        setInterval(() => fetchConfig(), CONFIG_POLL_INTERVAL);

        // ─── Keyboard Lockdown (production kiosk) ───
        document.addEventListener('keydown', (e) => {
            // Allow Ctrl+Alt+Shift+O for system config overlay
            if (e.ctrlKey && e.altKey && e.shiftKey && e.key === 'O') {
                window.location.href = '/system_config.html';
                return;
            }
            // Block everything else
            e.preventDefault();
            e.stopPropagation();
        }, true);

        document.addEventListener('contextmenu', e => e.preventDefault());

        // ─── Init ───
        async function init() {
            document.body.classList.add('ready', 'locked');
            setStatus('syncing', 'connecting');
            connectWebSocket();

            // Wait a moment for WS registration, then fetch config
            setTimeout(async () => {
                await fetchConfig();
            }, 2000);
        }

        init();
    </script>
</body>

</html>